# MCU команды

В этом документе содержится информация о низкоуровневых командах микроконтроллера, которые отправляются из «хост-программы» Klipper и обрабатываются программным обеспечением микроконтроллера Klipper. Этот документ не является авторитетным справочником по этим командам и не является эксклюзивным списком всех доступных команд.

Этот документ может быть полезен разработчикам, заинтересованным в понимании низкоуровневых команд микроконтроллера.

См. документ [protocol](Protocol.md) для получения дополнительной информации о формате команд и их передаче. Команды здесь описываются с использованием их синтаксиса в стиле «printf» — для тех, кто не знаком с этим форматом, просто обратите внимание, что там, где встречается последовательность '%...', ее следует заменить фактическим целым числом. Например, описание «count=%c» можно заменить текстом «count=10». Обратите внимание, что параметры, которые считаются «перечислениями» (см. приведенный выше протокольный документ), принимают строковое значение, которое автоматически преобразуется в целочисленное значение для микроконтроллера. Это характерно для параметров с именем «pin» (или с суффиксом «_pin»).

## Команды запуска

Может потребоваться выполнение определенных разовых действий по настройке микроконтроллера и его периферийных устройств. В этом разделе перечислены общие команды, доступные для этой цели. В отличие от большинства команд микроконтроллера, эти команды выполняются, как только они получены, и они не требуют какой-либо специальной настройки.

Общие команды запуска:

* `set_digital_out pin=%u value=%c` : эта команда немедленно настраивает данный контакт как цифровой выход GPIO и устанавливает для него либо низкий уровень (значение = 0), либо высокий уровень (значение = 1). Эта команда может быть полезна для настройки начального значения светодиодов LED и для настройки начального значения микрошаговых контактов драйвера шагового двигателя.
* `set_pwm_out pin=%u cycle_ticks=%u value=%hu` : Эта команда немедленно настроит данный вывод для использования аппаратной широтно-импульсной модуляции (ШИМ) с заданным количеством cycle_ticks. «cycle_ticks» — это количество тиков часов MCU, которое должен длиться каждый цикл включения и выключения питания. Значение cycle_ticks, равное 1, может использоваться для запроса максимально возможного времени цикла. Параметр «значение» находится в диапазоне от 0 до 255, где 0 указывает на полное выключение, а 255 указывает на полное включение. Эта команда может быть полезна для включения вентиляторов охлаждения ЦП и сопла.

## Конфигурация микроконтроллера низкого уровня

Большинство команд в микроконтроллере требуют первоначальной настройки, прежде чем их можно будет успешно вызывать. В этом разделе представлен обзор процесса настройки. Этот раздел и следующие разделы, вероятно, будут интересны только разработчикам, интересующимся внутренними деталями Klipper.

Когда хост впервые подключается к микроконтроллеру, он всегда начинает с получения словаря данных (см. [protocol](Protocol.md) для получения дополнительной информации). После получения словаря данных хост проверит, находится ли микроконтроллер в «настроенном» состоянии, и настроит его, если нет. Конфигурация включает в себя следующие этапы:

* `get_config` : Хост начинает с проверки, настроен ли уже микроконтроллер. Микроконтроллер отвечает на эту команду ответным сообщением «config». Программное обеспечение микроконтроллера всегда запускается в ненастроенном состоянии при включении питания. Он остается в этом состоянии до тех пор, пока хост не завершит процессы настройки (выполнив команду finalize_config). Если микроконтроллер уже сконфигурирован из предыдущего сеанса (и сконфигурирован с нужными параметрами), то от хоста не требуется никаких дальнейших действий, и процесс конфигурирования завершается успешно.
* `allocate_oids count=%c`: эта команда выдается для информирования микроконтроллера о максимальном количестве идентификаторов объектов (oid), которое требуется хосту. Данную команду допустимо выполнить только один раз. oid это целочисленный идентификатор, назначенный каждому степперу, каждому концевому упору и каждому планируемому выводу gpio. Хост заранее определяет количество oid, которое потребуется для работы оборудования, и передает его микроконтроллеру, чтобы он мог выделить достаточно памяти для хранения отображения от oid к внутреннему объекту.
* `config_XXX oid=%c ...` : По соглашению любая команда, начинающаяся с префикса «config_», создает новый объект микроконтроллера и назначает ему данный oid. Например, команда config_digital_out настроит указанный вывод как цифровой вывод GPIO и создаст внутренний объект, который хост может использовать для планирования изменений в данном GPIO. Параметр oid, передаваемый в команду config, выбирается хостом и должен быть между нулем и максимальным значением, указанным в команде allocate_oids. Команды config могут выполняться только тогда, когда микроконтроллер не находится в сконфигурированном состоянии (т. е. до отправки хостом finalize_config) и после отправки команды allocate_oids.
* `finalize_config crc=%u`: команда Finalize_config переводит микроконтроллер из ненастроенного состояния в настроенное состояние. Параметр crc, передаваемый микроконтроллеру, сохраняется и передается хосту в ответных сообщениях «config». По соглашению хост принимает 32-битный CRC конфигурации, которую он запрашивает, и в начале последующих сеансов связи проверяет, что CRC, хранящийся в микроконтроллере, точно соответствует желаемому CRC. Если CRC не совпадает, то хост знает, что микроконтроллер не настроен в желаемом хостом состоянии.

### Общие объекты микроконтроллера

В этом разделе перечислены некоторые часто используемые команды конфигурации.

* `config_digital_out oid=%c pin=%u value=%c default_value=%c max_duration=%u`: эта команда создает внутренний объект микроконтроллера для данного контакта GPIO. Вывод будет настроен в режиме цифрового выхода и ему будет присвоено начальное значение, указанное в «значении» (0 для низкого уровня, 1 для высокого уровня). Создание объекта digital_out позволяет хосту планировать обновления GPIO для данного вывода в указанное время (см. команду Queue_digital_out, описанную ниже). Если программное обеспечение микроконтроллера перейдет в режим выключения, то для всех настроенных объектов digital_out будет установлено значение «default_value». Параметр «max_duration» используется для реализации проверки безопасности: если он не равен нулю, то это максимальное количество тактов, в течение которых хост может установить для данного GPIO значение, отличное от значения по умолчанию, без дальнейших обновлений. Например, если default_value равно нулю, а max_duration равно 16000, то если хост устанавливает для gpio значение, равное единице, он должен запланировать еще одно обновление вывода gpio (до нуля или до единицы) в течение 16000 тактов часов. Эту функцию безопасности можно использовать с контактами нагревателя, чтобы гарантировать, что хост не включит нагреватель и не отключится от сети.
* `config_pwm_out oid=%c pin=%u cycle_ticks=%u value=%hu default_value=%hu max_duration=%u` : Эта команда создает внутренний объект для аппаратных выводов ШИМ, для которых хост может планировать обновления. Его использование аналогично config_digital_out ‐ описание параметров см. в описании команд set_pwm_out и config_digital_out.
* `config_analog_in oid=%c pin=%u`: эта команда используется для настройки вывода в режиме выборки аналогового входа. После настройки вывод может быть выбран через регулярные промежутки времени с помощью команды query_analog_in (см. ниже).
* `config_stepper oid=%c Step_pin=%c dir_pin=%c invert_step=%c step_pulse_ticks=%u` : Эта команда создает внутренний объект шагового двигателя. Параметры «step_pin» и «dir_pin» определяют выводы шага и направления соответственно; эта команда настроит их в режим цифрового вывода. Параметр invert_step указывает, происходит ли шаг по нарастающему фронту (invert_step=0) или по спадающему фронту (invert_step=1). Параметр «step_pulse_ticks» определяет минимальную длительность шагового импульса. Если микроконтроллер экспортирует константу «STEPPER_BOTH_EDGE=1», то установка step_pulse_ticks=0 и invert_step=-1 будет настроена для наступления как на восходящий, так и на спадающий фронты ступенчатого вывода.
* `config_endstop oid=%c pin=%c pull_up=%c Stepper_count=%c` : Эта команда создает внутренний объект «endstop». Он используется для указания выводов endstop и включения операций «наведения» (см. команду endstop_home ниже). Команда настроит указанный вывод в режим цифрового входа. Параметр pull_up определяет, будут ли включены аппаратные подтягивающие резисторы для вывода (если они доступны). Параметр «stepper_count» определяет максимальное количество шаговиков, которые этому конечному упору может потребоваться остановить во время операции возврата в исходное положение (см. endtop_home ниже).
* `config_spi oid=%c bus=%u pin=%u mode=%urate=%ushutdown_msg=%*s`: эта команда создает внутренний объект SPI. Он используется с командами spi_transfer и spi_send (см. ниже). «Шина» идентифицирует используемую шину SPI (если микроконтроллер имеет более одной доступной шины SPI). «Вывод» определяет вывод выбора чипа (CS) для устройства. «Режим» — это режим SPI (должен быть между 0 и 3). Параметр «rate» определяет скорость шины SPI (в циклах в секунду). Наконец, «shutdown_msg» — это команда SPI, которую необходимо отправить данному устройству, если микроконтроллер перейдет в состояние выключения.
* `config_spi_without_cs oid=%c bus=%u mode=%urate=%ushutdown_msg=%*s`: эта команда похожа на config_spi, но без определения контакта CS. Это полезно для устройств SPI, у которых нет линии выбора чипа.

## Общие команды

В этом разделе перечислены некоторые часто используемые команды времени выполнения. Вероятно, это будет интересно только разработчикам, желающим получить представление о Klipper.

* `set_digital_out_pwm_cycle oid=%ccycle_ticks=%u` : Эта команда настраивает цифровой выходной контакт (созданный config_digital_out) для использования «программного ШИМ». «cycle_ticks» — это количество тактов для цикла ШИМ. Поскольку переключение выходов реализовано в программном обеспечении микроконтроллера, рекомендуется, чтобы «cycle_ticks» соответствовало времени 10 мс или больше.
* `queue_digital_out oid=%c clock=%u on_ticks=%u`: эта команда запланирует изменение цифрового вывода GPIO в заданное время часов. Чтобы использовать эту команду, во время настройки микроконтроллера должна быть введена команда «config_digital_out» с тем же параметром «oid». Если был вызван «set_digital_out_pwm_cycle», то «on_ticks» — это продолжительность включения (в тактах) для цикла ШИМ. В противном случае «on_ticks» должно быть либо 0 (для низкого напряжения), либо 1 (для высокого напряжения).
* `queue_pwm_out oid=%c clock=%u value=%hu` : Планирует изменение аппаратного вывода ШИМ. Дополнительные сведения см. в командах «queue_digital_out» и «config_pwm_out».
* `query_analog_in oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u min_value=%hu max_value=%hu` : Эта команда устанавливает повторяющийся график выборок аналогового входа. Чтобы использовать эту команду, во время настройки микроконтроллера должна быть введена команда «config_analog_in» с тем же параметром «oid». Выборки начнутся с момента времени «lock», он будет сообщать о полученном значении каждые такты часов «rest_ticks», будет выполнять избыточную выборку количества «sample_count» раз и будет приостанавливать количество тактов «sample_ticks» между -пробные образцы. Параметры min_value и max_value реализуют функцию безопасности — программное обеспечение микроконтроллера проверяет, что выбранное значение (после любой передискретизации) всегда находится в пределах предоставленного диапазона. Он предназначен для использования с контактами, прикрепленными к термисторам, управляющим нагревателями, — его можно использовать для проверки того, что нагреватель находится в заданном температурном диапазоне.
* `get_clock`: эта команда заставляет микроконтроллер генерировать ответное сообщение «часы». Хост посылает эту команду один раз в секунду, чтобы получить значение часов микроконтроллера и оценить дрейф между часами хоста и микроконтроллера. Это позволяет хосту точно оценить тактовую частоту микроконтроллера.

### Шаговые команды

* `queue_step oid=%c интервал=%u count=%hu add=%hi` : Эта команда планирует количество шагов для данного шагового двигателя с интервалом между тактами часов между каждым шагом. Первым шагом будет «интервал» количества тактов с момента последнего запланированного шага для данного шагового двигателя. Если «добавить» не равно нулю, то интервал будет корректироваться на «добавляемую» сумму после каждого шага. Эта команда добавляет заданную последовательность интервал/счет/добавление в пошаговую очередь. Во время нормальной работы в очереди могут находиться сотни таких последовательностей. Новая последовательность добавляется в конец очереди, и по мере того, как каждая последовательность завершает свое «подсчетное» количество шагов, она выталкивается из начала очереди. Эта система позволяет микроконтроллеру потенциально ставить в очередь сотни тысяч шагов - и все это с надежным и предсказуемым графиком.
* `set_next_step_dir oid=%c dir=%c` : эта команда указывает значение dir_pin, которое будет использовать следующая команда queue_step.
* `reset_step_clock oid=%c clock=%u` : Как правило, синхронизация шага соответствует последнему шагу для данного шага. Эта команда сбрасывает тактовый сигнал так, чтобы следующий шаг был связан с предоставленным временем тактового сигнала. Обычно хост отправляет эту команду только в начале печати.
* `stepper_get_position oid=%c`: эта команда заставляет микроконтроллер генерировать ответное сообщение «stepper_position» с текущей позицией шагового двигателя. Позиция представляет собой общее количество шагов, созданных при dir=1, минус общее количество шагов, созданных при dir=0.
* `endstop_home oid=%c clock=%u sample_ticks=%u sample_count=%c rest_ticks=%u pin_value=%c` : Эта команда используется во время операций "возврата" шагового двигателя. Чтобы использовать эту команду, во время настройки микроконтроллера должна быть введена команда «config_endstop» с тем же параметром «oid». Когда эта команда вызывается, микроконтроллер будет считывать конечный вывод с каждого такта «rest_ticks» и проверять, имеет ли он значение, равное «pin_value». Если значение совпадает (и оно продолжает совпадать с дополнительными выборками «sample_count», разнесенными по «sample_ticks»), то очередь перемещения для соответствующего шагового двигателя будет очищена, и шаговый двигатель немедленно остановится. Хост использует эту команду для реализации возврата в исходное положение — хост дает указание конечному ограничителю выполнить выборку для триггера конечного упора, а затем выдает серию командqueue_step для перемещения шагового двигателя к конечному упору. Как только шаговый двигатель достигнет конечного упора, триггер будет обнаружен, движение остановлено и хост уведомлен.

### Очередь перемещения

Каждая команда queue_step использует запись в «очереди перемещения» микроконтроллера. Эта очередь выделяется при получении команды «finalize_config» и сообщает о количестве доступных записей в очереди в ответных сообщениях «config».

Хост несет ответственность за обеспечение наличия свободного места в очереди перед отправкой команды queue_step. Хост делает это, вычисляя время завершения каждой команды queue_step и соответствующим образом планируя новые команды queue_step.

### SPI-команды

* `spi_transfer oid=%c data=%*s`: эта команда заставляет микроконтроллер отправлять «данные» на устройство spi, указанное в «oid», и генерирует ответное сообщение «spi_transfer_response» с данными, возвращенными во время передачи. .
* `spi_send oid=%c data=%*s`: эта команда аналогична «spi_transfer», но она не генерирует сообщение «spi_transfer_response».

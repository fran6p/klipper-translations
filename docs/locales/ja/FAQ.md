# よくある質問

## このプロジェクトに寄付するにはどうすればいいですか？

ご支援ありがとうございます。詳しくは [スポンサーページ](Sponsors.md) をご覧ください。

## rotation_distance の設定パラメーターはどのように計算すれば良いですか？

[回転距離に関するドキュメント](Rotation_Distance.md) を参照してください。

## シリアルポートはどこですか？ {#wheres-my-serial-port}

USBシリアルポートを見つける一般的な方法は、ホストマシンのsshターミナルから `ls /dev/serial/by-id/*` を実行することです。以下のような出力が得られるはずです:

```
/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0
```

上記のコマンドで見つかった名前は安定しており、configファイルやマイクロコントローラーのコードをフラッシュする際に使用することができます。例えば、フラッシュ・コマンドは以下のようになります：

```
sudo service klipper stop
make flash FLASH_DEVICE=/dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0
sudo service klipper start
```

更新されたconfigの内容は次のようになります:

```
[mcu]
serial: /dev/serial/by-id/usb-1a86_USB2.0-Serial-if00-port0
```

プリンタごとに名前が異なるため、上記で実行した "ls" コマンドの名前をコピー＆ペーストしてください。

複数のマイクロコントローラーを使用していて、それらがユニークなIDを持っていない場合（CH340 USBチップを搭載したボードでは一般的）、代わりに `ls /dev/serial/by-path/*` コマンドを使用して上記の指示に従ってください。

## マイクロコントローラーが再起動すると、デバイスは /dev/ttyUSB1 に変わります

これを防ぐには、"[シリアルポートはどこですか?](#wheres-my-serial-port)" のセクションの指示に従ってください。

## "make flash" コマンドが機能しません

このコードでは、各プラットフォームで最も一般的な方法でデバイスのフラッシュを試みます。残念ながら、フラッシュ方法には多くの方法があるため、"make flash" コマンドはすべてのボードで動作するとは限りません。

もし断続的な失敗があるか、標準的なセットアップをしているのであれば、フラッシュ時にKlipperが動作していないか確認してください。（動作している場合、 `sudo service klipper stop` で Klipper を停止してください）OctoPrint がデバイスに直接接続しようとしていないか確認してください。（ウェブページの Connection タブを開き、シリアルポートがデバイスに設定されている場合は Disconnect をクリックしてください）FLASH_DEVICE がボードに正しく設定されているかを再確認してください。（上の[質問](#wheres-my-serial-port)を参照してください）

それでも "make flash" がうまくいかない場合は、手動でフラッシュする必要があります。[configディレクトリ](../config)に、デバイスをフラッシュするための具体的な手順が記述されたconfigファイルがあるかどうかを確認してください。また、ボードの製造元のドキュメントをチェックして、デバイスをフラッシュする方法が記載されているかどうかを確認してください。最後に、"avrdude"や "bossac"のようなツールを使って、手動でデバイスをフラッシュすることができるかもしれません - 追加情報については、[bootloader document](Bootloaders.md)を参照してください。

## シリアル・ボーレートを変更するにはどうすればよいですか？

Klipper の推奨ボーレートは 250000 です。このボーレートは、Klipper がサポートしている全てのマイコンボードで動作します。もし別のボーレートを推奨しているオンラインガイドを見つけたのであれば、その部分は無視して、デフォルトの250000を使い続けてください。

ボーレートを変更したい場合は、新しいレートをマイクロコントローラに(**make menuconfig**の中で)設定し、更新されたコードをコンパイルしてマイクロコントローラにフラッシュする必要があります。また、Klipperの printer.cfg ファイルも、そのボーレートに合うように更新する必要があります (詳細については、[config reference](Config_Reference.md#mcu) を参照してください)。例:

```
[mcu]
baud: 250000
```

OctoPrint のウェブページに表示されているボーレートはKlipper のマイクロコントローラー内部のボーレートに影響 はありません。Klipper を使用するときは OctoPrint のボーレートを常に 250000 に設定してください。

Klipper のマイクロコントローラのボーレートは、マイクロコントローラのブートローダのボーレートとは関係ありません。ブートローダに関する追加情報については、[ブートローダ・ドキュメント](Bootloaders.md) を参照してください。

## Raspberry Pi 3以外でKlipperを動かすことはできますか？

推奨ハードウェアは、Raspberry Pi 2、Raspberry Pi 3、またはRaspberry Pi 4です。

KlipperはRaspberry Pi 1やRaspberry Pi Zeroでも動作しますが、これらのボードにはOctoPrintをうまく動作させるのに十分な処理能力がありません。OctoPrintから直接プリントする場合、これらの遅いマシンではプリントストールが発生することがよくあります。(プリンターは OctoPrint が動作コマンドを送るよりも速く動くかもしれません。) もし、これらの遅いボードで動作させたい場合は、印刷時に "virtual_sdcard" 機能を使うことを検討してください (詳しくは [config reference](Config_Reference.md#virtual_sdcard) を参照してください)。

Beaglebone上での動作については、[Beaglebone固有のインストール手順](Beaglebone.md)を参照してください。

Klipperは他のマシンでも動作します。Klipperのホストソフトウエアは、Linux (または類似のOS) のコンピュータ上でPythonが動作している必要があります。ただし、異なるマシンで実行する場合は、その特定のマシンにシステムの必要条件を満たすための Linux 管理者の知識が必要になります。 必要な Linux 管理手順の詳細については、[install-octopi.sh](../scripts/install-octopi.sh) スクリプトを参照してください。

ローエンドのチップ上でKlipper ホストソフトウェアを動かしたいのであれば、最低でも"倍精度浮動小数点"演算器を搭載したマシンが必要であることに注意してください。

共有の汎用デスクトップやサーバークラスのマシンでKlipper ホストソフトウェアを実行したい場合、Klipper にはリアルタイムスケジューリング要件があることに注意してください。もし印刷中に、ホストコンピュータが集中的な汎用コンピューティングタスク（ハードドライブのデフラグ、3Dレンダリング、ヘビースワップなど）を実行した場合、Klipperが印刷エラーを報告する可能性があります。

Note: OctoPi イメージを使用していない場合、いくつかの Linux ディストリビューションでは "ModemManager" (または類似の) パッケージがシリアル通信を妨害する可能性があることに注意してください。(これは、Klipper が一見ランダムに "Lost communication with MCU" エラーを報告する原因になります)。これらのディストリビューションに Klipper をインストールする場合、そのパッケージを無効にする必要があるかもしれません。

## 同じホストマシン上で複数のKlipperを実行できますか？

Klipperホスト・ソフトウェアの複数のインスタンスを実行することは可能ですが、そのためには Linux 管理の知識が必要です。Klipperのインストールスクリプトは、最終的に以下のUnixコマンドを実行させます：

```
~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer.cfg -l /tmp/klippy.log
```

各インスタンスが独自のプリンター設定ファイル、独自のログファイル、独自の擬似ttyを持つ限り、上記のコマンドを複数実行することができます。例:

```
~/klippy-env/bin/python ~/klipper/klippy/klippy.py ~/printer2.cfg -l /tmp/klippy2.log -I /tmp/printer2
```

この選択をした場合、必要な起動、停止、インストールスクリプト(もしあれば)を実装する必要があります。[install-octopi.sh](../scripts/install-octopi.sh) スクリプトと、 [klipper-start.sh](../scripts/klipper-start.sh) スクリプトが、例として役に立つでしょう。

## OctoPrintを使わなければなりませんか？

Klipper のソフトウェアは OctoPrint に依存していません。 別のソフトウェアを使って Klipper にコマンドを送ることは可能ですが、そのためには Linux の管理者としての知識が必要です。

Klipper は、 "/tmp/printer" ファイルを通して "仮想シリアルポート" を作成し、そのファイルを通して古典的な3dプリンタのシリアルインターフェースをエミュレートします。一般に、プリンタのシリアルポートに "/tmp/printer" を使うように設定できる限り、代替ソフトウェアはKlipperで動作します。

## プリンターを原点復帰させる前にステッパーを動かせないのはなぜですか？

これは、誤ってベッドや壁にヘッドを衝突させる可能性を減らすためです。プリンタが原点復帰すると、ソフトウェアは各移動が設定ファイルで定義された position_min/max の範囲内であることを確認しようとします。モータが（M84またはM18コマンドによって）無効になっている場合は、移動の前にモータを再度原点復帰させる必要があります。

OctoPrint でプリントをキャンセルした後にヘッドを移動させたい場合は、OctoPrint のキャンセ ルシーケンスを変更してください。OctoPrint の設定はウェブブラウザーで行います: Settings->GCODE Scripts

印刷終了後にヘッドを移動させたい場合は、スライサーの "custom g-code" セクションに希望の動作を追加することを検討してください。

プリンターが原点復帰プロセスの一部として追加の動作が必要な場合（または基本的に原点復帰プロセスが存在しない場合）、configファイルに safe_z_home または homing_override セクションを使用することを検討してください。診断やデバッグのためにステッピングモータを動かす必要がある場合は、configファイルに force_move セクションを追加することを検討してください。これらのオプションに関する詳細は、[設定リファレンス](Config_Reference.md#customized_homing) を参照してください。

## Z position_endstop がデフォルト設定で0.5に設定されているのはなぜですか？

カーテシアンスタイルのプリンタでは、Z position_endstopは、エンドストップがトリガーされたときにノズルがベッドからどのくらい離れているかを指定します。可能であれば、Z-maxエンドストップを使用し、ベッドから離れた位置に原点復帰することをお勧めします（ベッドとの衝突の可能性が低くなるため）。しかし、ベッドに向かって原点復帰しなければならない場合は、ノズルがベッドからまだ少し離れているときにエンドストップのトリガーが掛かるように位置決めすることをお勧めします。こうすることで、軸を原点復帰させる際、ノズルがベッドに接触する前に停止します。詳細については、[ベッドレベルのドキュメント](Bed_Level.md)を参照してください。

## Marlin からコンフィグをコンバートしたところ、X/Y軸は問題なく動作しましたが、Z軸を原点復帰させるときに金切り声のようなノイズが発生しました

Short answer: まず、[config check document](Config_checks.md)で説明されているようにステッパーの設定を確認してください。問題が解決しない場合は、プリンター設定の max_z_velocity の設定を下げてみてください。

Long answer: 実際には、 Marlinは一般に 10000 step/s のステップレートでしかステップ信号を出力できません。もし、高いステップレートが必要な速度で動くように要求された場合、 Marlin は一般的に、できる限りの速度でステップ信号を出力します。 Klipper はもっと高いステップレートを実現できますが、ステッピングモーターは高速で動くのに十分なトルクを持っていない可能性があります。そのため、減速比の高いZ軸や、大きな分割数のマイクロステップ駆動のZ軸の場合、実際に得られる max_z_velocity はMarlinで設定されている値よりも小さくなる可能性があります。

## TMCモータードライバーの電源が印刷の途中で切れてしまいます

TMC2208（またはTMC2224）ドライバーを "スタンドアローンモード" で使用する場合は、必ず [最新版の Klipper](#how-do-i-upgrade-to-the-latest-software) を使用してください。2020年3月中旬に、TMC2208ドライバーの "stealthchop" 問題の回避策が Klipper に追加されました。

## ランダムに "Lost communication with MCU" というエラーが発生し続けます

これは一般的に、ホストマシンとマイクロコントローラー間のUSB接続におけるハードウェアエラーが原因です。確認するべきこと:

- ホストマシンとマイクロコントローラーの間には、 質の良いUSBケーブルを使用してください。プラグがしっかり固定されていることを確認してください。
- Raspberry Piを使用する場合、Raspberry Pi用の[良質な電源](https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#power-supply)を使用し、その電源とRaspberry Piを接続するために[良質なUSBケーブル](https://forums.raspberrypi.com/viewtopic.php?p=589877#p589877)を使用してください。もしOctoPrintから "電圧不足" の警告が表示される場合は、電源が関係していますので、修正してください。
- プリンタの電源が過負荷になっていないか確認してください。(マイクロコントローラーのUSBチップへ供給する電源の変動は、そのチップのリセットを引き起こす可能性があります。)
- ステッパー、ヒーター、その他のプリンタの配線に圧着不良や摩耗がないか確認してください。(プリンタが動くと、不具合のあるワイヤにストレスがかかり、接触不良を起こしたり、瞬間的なショートしたり、過剰なノイズが発生したりすることがあります。)
- プリンタの電源とホストの5V電源が混在(衝突)している場合、USBノイズが大きくなるという報告があります。(プリンターの電源がオンかUSBケーブルが差し込まれているときにマイクロコントローラーの電源がオンになる場合は、5V電源が混在していることを示しています)1つの電源だけを使用するようにマイクロコントローラーを構成すると有効かもしれません。(マイクロコントローラ基板の電源接続を変更できない場合、USBケーブルを改造して、ホストとマイクロコントローラ間での5V電源の供給を遮断することも一つの方法です。)

## 印刷中にRaspberry Piが再起動し続けます

これは電圧変動が原因の可能性が高いです。["Lost communication with MCU"](#i-keep-getting-random-lost-communication-with-mcu-errors)エラーと同じトラブルシューティング手順に従ってください。

## `restart_method=command` に設定すると、AVRデバイスが再起動時にハングします

いくつかの古いバージョンのAVRブートローダには、ウォッチドッグイベント処理に関する既知のバグがあります。これは通常 printer.cfg ファイルで restart_method が "command" に設定されている時に現れます。このバグが発生すると、AVRデバイスは電源を再投入するまで無反応になります。（電源をOFFするまで、電源またはステータスLEDが繰り返し点滅することもあります。）

回避策は "command" 以外の restart_method を使用するか、更新されたブートローダをAVRデバイスにフラッシュすることです。新しいブートローダのフラッシュは一般的に外部プログラマを必要とする1回限りのステップです - 更なる詳細については[Bootloaders](Bootloaders.md)を参照してください。

## Raspberry Pi がクラッシュした場合、ヒーターはつけっぱなしになりますか？

ソフトウェアはそれを防ぐように設計されています。ホストがヒーターを有効にすると、ホスト側のソフトウェアは5秒ごとにその有効化の確認する必要があります。マイクロコントローラーが5秒ごとに確認を受けなかった場合、すべてのヒーターとステッピングモーターをオフにするように設計された "シャットダウン" ステートに移行します。

詳細は[MCU commands](MCU_Commands.md)の "config_digital_out" コマンドを参照。

さらに、マイクロコントローラーのソフトウェアには、起動時に各ヒーターの最低温度範囲と最高温度範囲が設定されています。（詳細は[config reference](Config_Reference.md#extruder)のmin_tempとmax_tempパラメータを参照）マイクロコントローラーが温度がその範囲外であることを検出すると、「シャットダウン」状態にもなります。

これとは別に、ホスト・ソフトウェアには、ヒーターと温度センサーが正しく機能しているかどうかをチェックするコードも実装されています。詳細は[config reference](Config_Reference.md#verify_heater)を参照。

## Marlin のpin number を Klipper の pin name に変換するにはどうすればよいですか？

Short answer: マッピングは [sample-aliases.cfg](../config/sample-aliases.cfg)ファイルにあります。このファイルを、実際のマイクロコントローラのピン名を見つけるためのガイドとして使用してください。(関連する[board_pins](Config_Reference.md#board_pins)のconfigセクションをconfigファイルにコピーし、コンフィグでエイリアスを使用することも可能ですが、実際のマイクロコントローラのピン名を翻訳して使用することが望ましいです)sample-aliases.cfgファイルでは、"D"の代わりに接頭辞 "ar" で始まるピン名(例: Arduino pin `D23`はKlipperエイリアス `ar23`)、"A"の代わりに接頭辞 "analog"で始まるピン名(例: Arduino pin `A14`はKlipperエイリアス `analog14`)を使用していることに注意してください。

Long answer: Klipperはマイクロコントローラによって定義された標準的なピン名を使用します。Atmegaチップでは、これらのハードウェアピンは `PA4`、`PC7`、`PD2` のような名前を持っています。

昔、Arduinoプロジェクトは、標準的なハードウェアの名前を使わず、数字のインクリメントに基づいた独自のピン名を使うことにしました。これは不幸な選択で、多くの混乱を招きました。特にArduinoのピン番号は、同じハードウェアの名前に変換されないことがよくあります。例えば、`D21`はある一般的なArduinoボードでは`PD0`ですが、別の一般的なArduinoボードでは`PC7`です。

このような混乱を避けるため、Klipper のコア・コードでは、マイクロコントローラーで定義された標準的なピン名を使用しています。

## 特定のタイプのマイクロコントローラーのピンにデバイスを配線する必要がありますか？

デバイスのタイプとピンのタイプによります:

ADC ピン（またはアナログ・ピン）: サーミスタや同様の "アナログ" センサの場合、デバイスはマイクロコントローラの "analog" または "ADC"対応ピンに配線する必要があります。アナログ対応でないピンを使用するようにKlipper を設定した場合、Klipper は "Not a valid ADC pin" エラーを報告します。

PWMピン（またはタイマーピン）: Klipper は、デフォルトではどのデバイスにもハードウェアPWMを使用しません。そのため、一般的には、ヒーターやファン、同様のデバイスを、任意の汎用 IO ピンに配線することができます。しかし、ファンやoutput_pin デバイスは、オプションで`hardware_pwm: True`に設定することができます。この場合、マイクロコントローラはそのピンのハードウェア PWM をサポートしていなければなりません（そうでない場合、 Klipper は "Not a valid PWM pin" エラーを報告します）。

IRQピン（または割り込みピン）: Klipper はIOピンでハードウェア割り込みを使用しないため、これらのマイクロコントローラ・ピンにデバイスを配線する必要はありません。

SPIピン: ハードウェアSPIを使用する場合、ピンをマイクロコントローラのSPI対応ピンに配線する必要があります。しかし、ほとんどのデバイスは "software SPI" を使用するように設定することができ、その場合、任意の汎用IOピンを使用することができます。

I2Cピン: I2Cを使用する場合、ピンをマイクロコントローラーのI2C対応ピンに配線する必要があります。

その他のデバイスは、任意の汎用 IO ピンに配線できます。例えば、ステッパー、ヒーター、ファン、Zプローブ、サーボ、LED、一般的なhd44780/st7920 LCDディスプレイ、Trinamic UART制御ラインは、任意の汎用IOピンに配線できます。

## M109/M190の "温度待ち" リクエストをキャンセルするにはどうすれば良いですか？

OctoPrint のターミナルタブに移動し、ターミナルボックスで M112 コマンドを発行してください。M112 コマンドはKlipper を "シャットダウン" 状態にし、OctoPrint をKlipper から切断します。OctoPrint の接続エリアに移動し、"Connect" をクリックして OctoPrint を再接続してください。ターミナルタブに戻り FIRMWARE_RESTART コマンドを発行してKlipper エラー状態をクリアしてください。この手順が完了すると、前の加熱要求はキャンセルされ、新しいプリントを開始することができます。

## プリンターのステッピングモータが脱調したかを調べることはできますか？

ある意味で可能です。プリンターをホームポジションに戻し、`GET_POSITION`コマンドを実行します。その後、プリントを行い、もう一度ホームポジションに戻して`GET_POSITION`コマンドを実行します。そして`mcu:` と記された行の値を比較してください。

`GET_POSITION` コマンドの間に高速移動を実行するだけで、実際に何かを印刷してフィラメントを無駄にすることなく、ステッピングモーターの電流、加速度、速度などの設定を調整するのに役立つかもしれません。

エンドストップスイッチは微妙に異なる位置で動作する傾向があるため、数マイクロステップの差はエンドストップの誤差に起因する可能性が高いことに注意してください。ステッピングモーターは脱調すると、4フルステップ単位でずれが生じます。(つまり、16マイクロステップを使用している場合、ステッピングモータが脱調すると、"mcu:" ステップ・カウンターが64マイクロステップの倍数だけずれることになります。)

## なぜ Klipper はエラーを報告するのですか？プリントに失敗してしまいました！

Short answer: 私たちは、プリンターが問題を検出したかどうかを知りたいのです。そうすれば、根本的な問題を解決し、高品質なプリント結果を得ることができます。私たちは、プリンターが低品質のプリントを黙々と作成することを絶対に避けたいのです。

Long answer: Klipper は、多くの一時的な問題に自動的に対処するように設計されています。例えば、通信エラーを自動的に検出して再送信を行ったり、アクションを事前にスケジューリングし、断続的な干渉があっても正確なタイミングを維持するように、複数のレイヤーでコマンドをバッファリングします。しかし、ソフトウェアが回復不可能なエラーを検出したり、無効な動作を指示された場合、あるいは指示されたタスクを実行することが不可能であることを検出した場合、Klipper はエラーを報告します。このような状況では、低品質のプリント（またはそれ以上に悪いもの）を作成する可能性が高くなります。ユーザーに警告することで、根本的な問題を解決し、プリントの全体的な品質を向上させることを期待しています。

関連する質問がいくつかあります: なぜKlipperはプリントを一時停止しないのですか？警告を出さないのですか？プリント前にエラーをチェックしないのですか？ユーザーが入力したコマンドのエラーを無視するのですか？など。現在、KlipperはG-Codeプロトコルでコマンドを読み込んでいますが、G-Codeのプロトコルは今のところこれらの代替案を実用的にするほど柔軟ではありません。異常な状況でのユーザーエクスペリエンスを向上させるという開発者の関心はありますが、それにはG-Codeからの脱却を含むかなりのインフラ作りが必要だと考えられています。

## 最新のソフトウェアにアップグレードするにはどうすれば良いですか？

ソフトウェアをアップグレードする最初のステップは、最新の [config changes](Config_Changes.md) ドキュメントを確認することです。時折、ソフトウェアのアップグレードの一環として、ユーザーが設定を更新しなければならないような変更がソフトウェアに加えられることがあります。アップグレードの前にこのドキュメントを一読することをお勧めします。

アップグレードの準備ができたら、Raspberry Piにsshでログインして以下のコマンドを実行します:

```
cd ~/klipper
git pull
~/klipper/scripts/install-octopi.sh
```

その後、マイクロコントローラーのコードを再コンパイルしてフラッシュすることができます。例:

```
make menuconfig
make clean
make

sudo service klipper stop
make flash FLASH_DEVICE=/dev/ttyACM0
sudo service klipper start
```

ただし、ホストソフトウェアだけが更新されることもよくあります。その際には、ホストソフトウェアのみをアップデートして再起動することが可能です:

```
cd ~/klipper
git pull
sudo service klipper restart
```

この短縮手順を試したあと、ソフトウェアからマイクロコントローラーを再フラッシュする必要があるという警告や、他の異常なエラーが出た場合には、先ほど説明した完全なアップグレード手順に従ってください。

エラーが続く場合は、プリンタの設定を変更する必要があるかもしれません。[config changes](Config_Changes.md) ドキュメントを再度確認してください。

RESTART と FIRMWARE_RESTART g-codeコマンドは新しいソフトウェアをロードしないことに注意してください。ソフトウェアの変更を反映するには、上記の "sudo service klipper restart" と "make flash" コマンドが必要です。

## Klipperをアンインストールするには？

ファームウェアについては、特別なことは何も必要ありません。新しいファームウェアのフラッシュ指示に従うだけです。

ラズベリーパイについては、[scripts/klipper-uninstall.sh](../scripts/klipper-uninstall.sh) にアンインストールスクリプトが用意されています。例:

```
sudo ~/klipper/scripts/klipper-uninstall.sh
rm -rf ~/klippy-env ~/klipper
```

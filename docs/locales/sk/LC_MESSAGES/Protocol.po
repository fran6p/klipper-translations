# Spravko <spravko@azet.sk>, 2023.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2023-11-16 17:03+0000\n"
"Last-Translator: Spravko <spravko@azet.sk>\n"
"Language-Team: Slovak <https://hosted.weblate.org/projects/klipper/protocol/"
"sk/>\n"
"Language: sk\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"
"X-Generator: Weblate 5.2\n"

msgid ""
"The Klipper messaging protocol is used for low-level communication between "
"the Klipper host software and the Klipper micro-controller software. At a "
"high level the protocol can be thought of as a series of command and "
"response strings that are compressed, transmitted, and then processed at the"
" receiving side. An example series of commands in uncompressed human-"
"readable format might look like:"
msgstr ""
"Protokol správ Klipper sa používa na komunikáciu na nízkej úrovni medzi "
"hostiteľským softvérom Klipper a softvérom mikrokontroléra Klipper. Na "
"vysokej úrovni si protokol možno predstaviť ako sériu reťazcov príkazov a "
"odpovedí, ktoré sú komprimované, prenášané a potom spracované na prijímacej "
"strane. Príklad série príkazov v nekomprimovanom ľudsky čitateľnom formáte "
"môže vyzerať takto:"

msgid ""
"See the [mcu commands](MCU_Commands.md) document for information on "
"available commands. See the [debugging](Debugging.md) document for "
"information on how to translate a G-Code file into its corresponding human-"
"readable micro-controller commands."
msgstr ""
"Informácie o dostupných príkazoch nájdete v dokumente [mcu "
"commands](MCU_Commands.md). Pozrite si dokument [ladenie](Debugging.md), kde "
"nájdete informácie o tom, ako preložiť súbor G-kódu do jeho zodpovedajúcich "
"ľudsky čitateľných príkazov mikroovládača."

msgid ""
"This page provides a high-level description of the Klipper messaging "
"protocol itself. It describes how messages are declared, encoded in binary "
"format (the \"compression\" scheme), and transmitted."
msgstr ""
"Táto stránka poskytuje popis na vysokej úrovni samotného protokolu správ "
"Klipper. Popisuje, ako sa správy deklarujú, kódujú v binárnom formáte ("
"schéma „kompresie“) a ako sa prenášajú."

msgid ""
"The goal of the protocol is to enable an error-free communication channel "
"between the host and micro-controller that is low-latency, low-bandwidth, "
"and low-complexity for the micro-controller."
msgstr ""
"Cieľom protokolu je umožniť bezchybný komunikačný kanál medzi hostiteľom a "
"mikrokontrolérom, ktorý má nízku latenciu, malú šírku pásma a nízku "
"zložitosť pre mikrokontrolér."

msgid "Micro-controller Interface"
msgstr "Rozhranie mikrokontroléra"

msgid ""
"The Klipper transmission protocol can be thought of as a "
"[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
" micro-controller and host. The micro-controller software declares the "
"commands that the host may invoke along with the response messages that it "
"can generate. The host uses that information to command the micro-controller"
" to perform actions and to interpret the results."
msgstr ""
"Prenosový protokol Klipper si možno predstaviť ako mechanizmus "
"[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) medzi "
"mikroovládačom a hostiteľom. Softvér mikrokontroléra deklaruje príkazy, "
"ktoré môže hostiteľ vyvolať, spolu so správami s odpoveďami, ktoré môže "
"generovať. Hostiteľ používa tieto informácie na prikázanie mikrokontroléru, "
"aby vykonal akcie a interpretoval výsledky."

msgid "Declaring commands"
msgstr "Vyhlasovanie príkazov"

msgid ""
"The micro-controller software declares a \"command\" by using the "
"DECL_COMMAND() macro in the C code. For example:"
msgstr ""
"Softvér mikrokontroléra deklaruje \"príkaz\" pomocou makra DECL_COMMAND() v "
"kóde C. Napríklad:"

msgid ""
"The above declares a command named \"update_digital_out\". This allows the "
"host to \"invoke\" this command which would cause the "
"command_update_digital_out() C function to be executed in the micro-"
"controller. The above also indicates that the command takes two integer "
"parameters. When the command_update_digital_out() C code is executed, it "
"will be passed an array containing these two integers - the first "
"corresponding to the 'oid' and the second corresponding to the 'value'."
msgstr ""
"Vyššie uvedené deklaruje príkaz s názvom \"update_digital_out\". To umožňuje "
"hostiteľovi \"vyvolať\" tento príkaz, ktorý spôsobí, že sa v mikrokontroléri "
"vykoná funkcia command_update_digital_out() C. Vyššie uvedené tiež "
"naznačuje, že príkaz má dva celočíselné parametre. Keď sa vykoná kód "
"command_update_digital_out() C, odovzdá sa pole obsahujúce tieto dve celé "
"čísla - prvé zodpovedá 'oid' a druhé odpovedá 'hodnote'."

msgid ""
"In general, the parameters are described with printf() style syntax (eg, "
"\"%u\"). The formatting directly corresponds to the human-readable view of "
"commands (eg, \"update_digital_out oid=7 value=1\"). In the above example, "
"\"value=\" is a parameter name and \"%c\" indicates the parameter is an "
"integer. Internally, the parameter name is only used as documentation. In "
"this example, the \"%c\" is also used as documentation to indicate the "
"expected integer is 1 byte in size (the declared integer size does not "
"impact the parsing or encoding)."
msgstr ""
"Vo všeobecnosti sú parametre opísané syntaxou štýlu printf() (napr. \"%u\"). "
"Formátovanie priamo zodpovedá ľudskému čitateľnému pohľadu na príkazy (napr. "
"\"update_digital_out oid=7 hodnota=1\"). Vo vyššie uvedenom príklade je "
"\"value=\" názov parametra a \"%c\" označuje, že parameter je celé číslo. "
"Interne sa názov parametra používa iba ako dokumentácia. V tomto príklade sa "
"\"%c\" používa aj ako dokumentácia na označenie očakávaného celého čísla s "
"veľkosťou 1 bajtu (deklarovaná veľkosť celého čísla nemá vplyv na analýzu "
"ani kódovanie)."

msgid ""
"The micro-controller build will collect all commands declared with "
"DECL_COMMAND(), determine their parameters, and arrange for them to be "
"callable."
msgstr ""
"Zostava mikrokontroléra zhromaždí všetky príkazy deklarované pomocou "
"DECL_COMMAND(), určí ich parametre a zariadi, aby boli volateľné."

msgid "Declaring responses"
msgstr "Deklarovanie odpovedí"

msgid ""
"To send information from the micro-controller to the host a \"response\" is "
"generated. These are both declared and transmitted using the sendf() C "
"macro. For example:"
msgstr ""
"Na odoslanie informácií z mikroovládača hostiteľovi sa vygeneruje „odpoveď“. "
"Tieto sú deklarované a prenášané pomocou makra sendf() C. Napríklad:"

msgid ""
"The above transmits a \"status\" response message that contains two integer "
"parameters (\"clock\" and \"status\"). The micro-controller build "
"automatically finds all sendf() calls and generates encoders for them. The "
"first parameter of the sendf() function describes the response and it is in "
"the same format as command declarations."
msgstr ""
"Vyššie uvedené odošle správu s odpoveďou \"stav\", ktorá obsahuje dva "
"celočíselné parametre (\"hodiny\" a \"stav\"). Zostava mikrokontroléra "
"automaticky nájde všetky volania sendf() a vygeneruje pre ne kódovače. Prvý "
"parameter funkcie sendf() popisuje odpoveď a je v rovnakom formáte ako "
"deklarácie príkazov."

msgid ""
"The host can arrange to register a callback function for each response. So, "
"in effect, commands allow the host to invoke C functions in the micro-"
"controller and responses allow the micro-controller software to invoke code "
"in the host."
msgstr ""
"Hostiteľ môže zariadiť registráciu funkcie spätného volania pre každú "
"odpoveď. Takže v skutočnosti príkazy umožňujú hostiteľovi vyvolať funkcie C "
"v mikrokontroléri a odpovede umožňujú softvéru mikrokontroléra vyvolať kód v "
"hostiteľovi."

msgid ""
"The sendf() macro should only be invoked from command or task handlers, and "
"it should not be invoked from interrupts or timers. The code does not need "
"to issue a sendf() in response to a received command, it is not limited in "
"the number of times sendf() may be invoked, and it may invoke sendf() at any"
" time from a task handler."
msgstr ""
"Makro sendf() by malo byť vyvolané iba z príkazov alebo obsluhovačov úloh a "
"nemalo by byť vyvolané z prerušení alebo časovačov. Kód nemusí vydávať "
"sendf() ako odpoveď na prijatý príkaz, nie je obmedzený na počet vyvolaní "
"sendf() a môže kedykoľvek vyvolať sendf() z obsluhy úlohy."

msgid "Output responses"
msgstr "Výstupné odpovede"

msgid ""
"To simplify debugging, there is also an output() C function. For example:"
msgstr "Na zjednodušenie ladenia existuje aj funkcia output() C. Napríklad:"

msgid ""
"The output() function is similar in usage to printf() - it is intended to "
"generate and format arbitrary messages for human consumption."
msgstr ""
"Funkcia output() sa používa podobne ako printf() – je určená na generovanie "
"a formátovanie ľubovoľných správ pre ľudskú spotrebu."

msgid "Declaring enumerations"
msgstr "Vyhlasovanie súpisov"

msgid ""
"Enumerations allow the host code to use string identifiers for parameters "
"that the micro-controller handles as integers. They are declared in the "
"micro-controller code - for example:"
msgstr ""
"Enumerácie umožňujú hostiteľskému kódu používať reťazcové identifikátory pre "
"parametre, ktoré mikroovládač spracováva ako celé čísla. Sú deklarované v "
"kóde mikrokontroléra - napríklad:"

msgid ""
"If the first example, the DECL_ENUMERATION() macro defines an enumeration "
"for any command/response message with a parameter name of \"spi_bus\" or "
"parameter name with a suffix of \"_spi_bus\". For those parameters the "
"string \"spi\" is a valid value and it will be transmitted with an integer "
"value of zero."
msgstr ""
"V prvom príklade makro DECL_ENUMERATION() definuje enumeráciu pre ľubovoľnú "
"správu s príkazom/odpoveďou s názvom parametra \"spi_bus\" alebo názvom "
"parametra s príponou \"_spi_bus\". Pre tieto parametre je reťazec \"spi\" "
"platnou hodnotou a bude prenášaný s celočíselnou hodnotou nula."

msgid ""
"It's also possible to declare an enumeration range. In the second example, a"
" \"pin\" parameter (or any parameter with a suffix of \"_pin\") would accept"
" PC0, PC1, PC2, ..., PC7 as valid values. The strings will be transmitted "
"with integers 16, 17, 18, ..., 23."
msgstr ""
"Je tiež možné deklarovať rozsah enumerácie. V druhom príklade by parameter "
"\"pin\" (alebo akýkoľvek parameter s príponou \"_pin\") akceptoval PC0, PC1, "
"PC2, ..., PC7 ako platné hodnoty. Reťazce sa budú prenášať s celými číslami "
"16, 17, 18, ..., 23."

msgid "Declaring constants"
msgstr "Deklarovanie konštánt"

msgid "Constants can also be exported. For example, the following:"
msgstr "Konštanty je možné aj exportovať. Napríklad nasledujúce:"

msgid ""
"would export a constant named \"SERIAL_BAUD\" with a value of 250000 from "
"the micro-controller to the host. It is also possible to declare a constant "
"that is a string - for example:"
msgstr ""
"exportuje konštantu s názvom \"SERIAL_BAUD\" s hodnotou 250 000 z "
"mikrokontroléra do hostiteľa. Je tiež možné deklarovať konštantu, ktorá je "
"reťazcom - napríklad:"

msgid "Low-level message encoding"
msgstr "Nízkoúrovňové kódovanie správ"

msgid ""
"To accomplish the above RPC mechanism, each command and response is encoded "
"into a binary format for transmission. This section describes the "
"transmission system."
msgstr ""
"Aby sa dosiahol vyššie uvedený mechanizmus RPC, každý príkaz a odpoveď sú "
"zakódované do binárneho formátu na prenos. Táto časť popisuje prenosový "
"systém."

msgid "Message Blocks"
msgstr "Bloky správ"

msgid ""
"All data sent from host to micro-controller and vice-versa are contained in "
"\"message blocks\". A message block has a two byte header and a three byte "
"trailer. The format of a message block is:"
msgstr ""
"Všetky údaje odoslané z hostiteľa do mikrokontroléra a naopak sú obsiahnuté "
"v „blokoch správ“. Blok správ má dvojbajtovú hlavičku a trojbajtovú "
"upútavku. Formát bloku správ je:"

msgid ""
"The length byte contains the number of bytes in the message block including "
"the header and trailer bytes (thus the minimum message length is 5 bytes). "
"The maximum message block length is currently 64 bytes. The sequence byte "
"contains a 4 bit sequence number in the low-order bits and the high-order "
"bits always contain 0x10 (the high-order bits are reserved for future use). "
"The content bytes contain arbitrary data and its format is described in the "
"following section. The crc bytes contain a 16bit CCITT "
"[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
"block including the header bytes but excluding the trailer bytes. The sync "
"byte is 0x7e."
msgstr ""
"Byte dĺžky obsahuje počet bajtov v bloku správy vrátane bajtov hlavičky a "
"prívesku (minimálna dĺžka správy je teda 5 bajtov). Maximálna dĺžka bloku "
"správ je momentálne 64 bajtov. Sekvenčný bajt obsahuje 4 bitové poradové "
"číslo v bitoch nižšieho rádu a bity vyššieho rádu vždy obsahujú 0x10 (bity "
"vyššieho rádu sú rezervované pre budúce použitie). Obsahové bajty obsahujú "
"ľubovoľné údaje a ich formát je popísaný v nasledujúcej časti. Bajty crc "
"obsahujú 16-bitový CCITT [CRC](https://en.wikipedia.org/wiki/"
"Cyclic_redundancy_check) bloku správ vrátane bajtov hlavičky, ale bez bajtov "
"upútavky. Synchronizačný bajt je 0x7e."

msgid ""
"The format of the message block is inspired by "
"[HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control) message "
"frames. Like in HDLC, the message block may optionally contain an additional"
" sync character at the start of the block. Unlike in HDLC, a sync character "
"is not exclusive to the framing and may be present in the message block "
"content."
msgstr ""
"Formát bloku správ je inšpirovaný rámcami správ [HDLC](https://en.wikipedia."
"org/wiki/High-Level_Data_Link_Control). Podobne ako v HDLC môže blok správ "
"voliteľne obsahovať dodatočný synchronizačný znak na začiatku bloku. Na "
"rozdiel od HDLC nie je synchronizačný znak exkluzívny pre rámovanie a môže "
"byť prítomný v obsahu bloku správ."

msgid "Message Block Contents"
msgstr "Obsah bloku správ"

msgid ""
"Each message block sent from host to micro-controller contains a series of "
"zero or more message commands in its contents. Each command starts with a "
"[Variable Length Quantity](#variable-length-quantities) (VLQ) encoded "
"integer command-id followed by zero or more VLQ parameters for the given "
"command."
msgstr ""
"Každý blok správ odoslaný z hostiteľa do mikrokontroléra obsahuje vo svojom "
"obsahu sériu nula alebo viacerých príkazov správ. Každý príkaz začína s ["
"Variable Length Quantity](#variable-length-quantities) (VLQ) zakódovaným "
"celým číslom príkazu-id, za ktorým nasleduje nula alebo viacero parametrov "
"VLQ pre daný príkaz."

msgid ""
"As an example, the following four commands might be placed in a single "
"message block:"
msgstr ""
"Napríklad nasledujúce štyri príkazy môžu byť umiestnené v jednom bloku správ:"

msgid "and encoded into the following eight VLQ integers:"
msgstr "a zakódované do nasledujúcich ôsmich celých čísel VLQ:"

msgid ""
"In order to encode and parse the message contents, both the host and micro-"
"controller must agree on the command ids and the number of parameters each "
"command has. So, in the above example, both the host and micro-controller "
"would know that \"id_update_digital_out\" is always followed by two "
"parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
" The host and micro-controller share a \"data dictionary\" that maps the "
"command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
"integer command-ids. When processing the data, the parser will know to "
"expect a specific number of VLQ encoded parameters following a given command"
" id."
msgstr ""
"Aby bolo možné zakódovať a analyzovať obsah správy, hostiteľ aj "
"mikrokontrolér sa musia dohodnúť na ID príkazov a počte parametrov, ktoré má "
"každý príkaz. Takže vo vyššie uvedenom príklade by hostiteľ aj "
"mikrokontrolér vedeli, že za „id_update_digital_out“ vždy nasledujú dva "
"parametre a „id_get_config“ a „id_get_clock“ majú nulové parametre. Hostiteľ "
"a mikrokontrolér zdieľajú \"dátový slovník\", ktorý mapuje popisy príkazov ("
"napr. \"update_digital_out oid=%c value=%c\") na ich celočíselné ID "
"príkazov. Pri spracovaní údajov bude syntaktický analyzátor vedieť, že má "
"očakávať špecifický počet parametrov kódovaných VLQ po zadanom ID príkazu."

msgid ""
"The message contents for blocks sent from micro-controller to host follow "
"the same format. The identifiers in these messages are \"response ids\", but"
" they serve the same purpose and follow the same encoding rules. In "
"practice, message blocks sent from the micro-controller to the host never "
"contain more than one response in the message block contents."
msgstr ""
"Obsah správy pre bloky odoslané z mikrokontroléra hostiteľovi má rovnaký "
"formát. Identifikátory v týchto správach sú „identifikátory odpovedí“, ale "
"slúžia na rovnaký účel a riadia sa rovnakými pravidlami kódovania. V praxi "
"bloky správ odoslané z mikrokontroléra hostiteľovi nikdy neobsahujú viac ako "
"jednu odpoveď v obsahu bloku správ."

msgid "Variable Length Quantities"
msgstr "Množstvo s premenlivou dĺžkou"

msgid ""
"See the [wikipedia article](https://en.wikipedia.org/wiki/Variable-"
"length_quantity) for more information on the general format of VLQ encoded "
"integers. Klipper uses an encoding scheme that supports both positive and "
"negative integers. Integers close to zero use less bytes to encode and "
"positive integers typically encode using less bytes than negative integers. "
"The following table shows the number of bytes each integer takes to encode:"
msgstr ""
"Ďalšie informácie o všeobecnom formáte celých čísel kódovaných VLQ nájdete v "
"[článku wikipedie](https://en.wikipedia.org/wiki/Variable-length_quantity). "
"Klipper používa schému kódovania, ktorá podporuje kladné aj záporné celé "
"čísla. Celé čísla blízke nule používajú na kódovanie menej bajtov a kladné "
"celé čísla zvyčajne používajú menej bajtov ako záporné celé čísla. "
"Nasledujúca tabuľka zobrazuje počet bajtov, ktoré každé celé číslo potrebuje "
"na zakódovanie:"

msgid "Integer"
msgstr "Celé číslo"

msgid "Encoded size"
msgstr "Kódovaná veľkosť"

msgid "-32 .. 95"
msgstr "-32 .. 95"

msgid "1"
msgstr "1"

msgid "-4096 .. 12287"
msgstr "-4096 .. 12287"

msgid "2"
msgstr "2"

msgid "-524288 .. 1572863"
msgstr "-524288 .. 1572863"

msgid "3"
msgstr "3"

msgid "-67108864 .. 201326591"
msgstr "-67108864 .. 201326591"

msgid "4"
msgstr "4"

msgid "-2147483648 .. 4294967295"
msgstr "-2147483648 .. 4294967295"

msgid "5"
msgstr "5"

msgid "Variable length strings"
msgstr "Šnúrky s premenlivou dĺžkou"

msgid ""
"As an exception to the above encoding rules, if a parameter to a command or "
"response is a dynamic string then the parameter is not encoded as a simple "
"VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
"encoded integer followed by the contents itself:"
msgstr ""
"Ako výnimka z vyššie uvedených pravidiel kódovania, ak je parametrom príkazu "
"alebo odpovede dynamický reťazec, potom parameter nie je zakódovaný ako "
"jednoduché celé číslo VLQ. Namiesto toho sa kóduje prenosom dĺžky ako celého "
"čísla zakódovaného VLQ, za ktorým nasleduje samotný obsah:"

msgid ""
"The command descriptions found in the data dictionary allow both the host "
"and micro-controller to know which command parameters use simple VLQ "
"encoding and which parameters use string encoding."
msgstr ""
"Opisy príkazov nájdené v dátovom slovníku umožňujú hostiteľovi aj "
"mikrokontroléru vedieť, ktoré parametre príkazu používajú jednoduché "
"kódovanie VLQ a ktoré parametre používajú kódovanie reťazcov."

msgid "Data Dictionary"
msgstr "Dátový slovník"

msgid ""
"In order for meaningful communications to be established between micro-"
"controller and host, both sides must agree on a \"data dictionary\". This "
"data dictionary contains the integer identifiers for commands and responses "
"along with their descriptions."
msgstr ""
"Aby sa medzi mikroovládačom a hostiteľom vytvorila zmysluplná komunikácia, "
"obe strany sa musia dohodnúť na „slovníku údajov“. Tento dátový slovník "
"obsahuje celočíselné identifikátory pre príkazy a odpovede spolu s ich "
"popismi."

msgid ""
"The micro-controller build uses the contents of DECL_COMMAND() and sendf() "
"macros to generate the data dictionary. The build automatically assigns "
"unique identifiers to each command and response. This system allows both the"
" host and micro-controller code to seamlessly use descriptive human-readable"
" names while still using minimal bandwidth."
msgstr ""
"Zostava mikrokontroléra využíva obsah makier DECL_COMMAND() a sendf() na "
"generovanie dátového slovníka. Zostava automaticky priraďuje jedinečné "
"identifikátory každému príkazu a odpovedi. Tento systém umožňuje "
"hostiteľskému kódu aj kódu mikrokontroléra bezproblémovo používať popisné "
"mená čitateľné pre človeka pri použití minimálnej šírky pásma."

msgid ""
"The host queries the data dictionary when it first connects to the micro-"
"controller. Once the host downloads the data dictionary from the micro-"
"controller, it uses that data dictionary to encode all commands and to parse"
" all responses from the micro-controller. The host must therefore handle a "
"dynamic data dictionary. However, to keep the micro-controller software "
"simple, the micro-controller always uses its static (compiled in) data "
"dictionary."
msgstr ""
"Hostiteľ sa pri prvom pripojení k mikrokontroléru spýta na dátový slovník. "
"Keď hostiteľ stiahne dátový slovník z mikroovládača, použije tento dátový "
"slovník na zakódovanie všetkých príkazov a na analýzu všetkých odpovedí z "
"mikroovládača. Hostiteľ preto musí spracovať dynamický dátový slovník. Aby "
"bol softvér mikrokontroléra jednoduchý, mikrokontrolér vždy používa svoj "
"statický (skompilovaný) dátový slovník."

msgid ""
"The data dictionary is queried by sending \"identify\" commands to the "
"micro-controller. The micro-controller will respond to each identify command"
" with an \"identify_response\" message. Since these two commands are needed "
"prior to obtaining the data dictionary, their integer ids and parameter "
"types are hard-coded in both the micro-controller and the host. The "
"\"identify_response\" response id is 0, the \"identify\" command id is 1. "
"Other than having hard-coded ids the identify command and its response are "
"declared and transmitted the same way as other commands and responses. No "
"other command or response is hard-coded."
msgstr ""
"Dátový slovník sa dotazuje odoslaním príkazov „identifikovať“ "
"mikrokontroléru. Mikroovládač odpovie na každý identifikačný príkaz správou "
"\"identify_response\". Keďže tieto dva príkazy sú potrebné pred získaním "
"údajového slovníka, ich celočíselné identifikátory a typy parametrov sú "
"pevne zakódované v mikrokontroléri aj hostiteľovi. Identifikátor odpovede "
"\"identify_response\" je 0, ID príkazu \"identify\" je 1. Okrem pevne "
"zakódovaných identifikátorov sa príkaz identifikuje a jeho odpoveď deklaruje "
"a prenáša rovnakým spôsobom ako ostatné príkazy a odpovede. Žiadny iný "
"príkaz alebo odpoveď nie je pevne zakódovaná."

msgid ""
"The format of the transmitted data dictionary itself is a zlib compressed "
"JSON string. The micro-controller build process generates the string, "
"compresses it, and stores it in the text section of the micro-controller "
"flash. The data dictionary can be much larger than the maximum message block"
" size - the host downloads it by sending multiple identify commands "
"requesting progressive chunks of the data dictionary. Once all chunks are "
"obtained the host will assemble the chunks, uncompress the data, and parse "
"the contents."
msgstr ""
"Formát samotného slovníka prenášaných údajov je komprimovaný reťazec JSON "
"zlib. Proces zostavovania mikrokontroléra vygeneruje reťazec, skomprimuje ho "
"a uloží do textovej časti blesku mikrokontroléra. Dátový slovník môže byť "
"oveľa väčší ako maximálna veľkosť bloku správ – hostiteľ ho stiahne "
"odoslaním viacerých identifikačných príkazov požadujúcich progresívne časti "
"dátového slovníka. Po získaní všetkých častí hostiteľ zostaví časti, "
"dekomprimuje údaje a analyzuje obsah."

msgid ""
"In addition to information on the communication protocol, the data "
"dictionary also contains the software version, enumerations (as defined by "
"DECL_ENUMERATION), and constants (as defined by DECL_CONSTANT)."
msgstr ""
"Okrem informácií o komunikačnom protokole obsahuje dátový slovník aj verziu "
"softvéru, enumerácie (definované v DECL_ENUMERATION) a konštanty (definované "
"v DECL_CONSTANT)."

msgid "Message flow"
msgstr "Tok správ"

msgid ""
"Message commands sent from host to micro-controller are intended to be "
"error-free. The micro-controller will check the CRC and sequence numbers in "
"each message block to ensure the commands are accurate and in-order. The "
"micro-controller always processes message blocks in-order - should it "
"receive a block out-of-order it will discard it and any other out-of-order "
"blocks until it receives blocks with the correct sequencing."
msgstr ""
"Príkazy správ odosielané z hostiteľa do mikrokontroléra majú byť bezchybné. "
"Mikroovládač skontroluje CRC a poradové čísla v každom bloku správ, aby sa "
"uistil, že príkazy sú presné a v poriadku. Mikrokontrolér vždy spracováva "
"bloky správ v poradí - ak prijme blok mimo poradia, zahodí ho a všetky "
"ostatné bloky mimo poradia, kým neprijme bloky so správnym poradím."

msgid ""
"The low-level host code implements an automatic retransmission system for "
"lost and corrupt message blocks sent to the micro-controller. To facilitate "
"this, the micro-controller transmits an \"ack message block\" after each "
"successfully received message block. The host schedules a timeout after "
"sending each block and it will retransmit should the timeout expire without "
"receiving a corresponding \"ack\". In addition, if the micro-controller "
"detects a corrupt or out-of-order block it may transmit a \"nak message "
"block\" to facilitate fast retransmission."
msgstr ""
"Nízkoúrovňový hostiteľský kód implementuje systém automatického opätovného "
"prenosu stratených a poškodených blokov správ odoslaných do mikrokontroléra. "
"Aby sa to uľahčilo, mikroovládač vysiela \"blok správ na potvrdenie\" po "
"každom úspešne prijatom bloku správ. Hostiteľ naplánuje časový limit po "
"odoslaní každého bloku a ak vyprší časový limit, odošle ho znova bez "
"prijatia zodpovedajúceho \"potvrdenia\". Okrem toho, ak mikroovládač "
"deteguje poškodený alebo nefunkčný blok, môže preniesť „blok správ“ na "
"uľahčenie rýchleho opätovného prenosu."

msgid ""
"An \"ack\" is a message block with empty content (ie, a 5 byte message "
"block) and a sequence number greater than the last received host sequence "
"number. A \"nak\" is a message block with empty content and a sequence "
"number less than the last received host sequence number."
msgstr ""
"\"Potvrdenie\" je blok správ s prázdnym obsahom (tj 5-bajtový blok správ) a "
"poradovým číslom väčším ako posledné prijaté poradové číslo hostiteľa. \"Nak"
"\" je blok správ s prázdnym obsahom a poradovým číslom menším ako posledné "
"prijaté poradové číslo hostiteľa."

msgid ""
"The protocol facilitates a \"window\" transmission system so that the host "
"can have many outstanding message blocks in-flight at a time. (This is in "
"addition to the many commands that may be present in a given message block.)"
" This allows maximum bandwidth utilization even in the event of transmission"
" latency. The timeout, retransmit, windowing, and ack mechanism are inspired"
" by similar mechanisms in "
"[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)."
msgstr ""
"Protokol uľahčuje \"okenný\" prenosový systém, takže hostiteľ môže mať počas "
"letu veľa nevyriešených blokov správ naraz. (Toto je doplnok k mnohým "
"príkazom, ktoré môžu byť prítomné v danom bloku správ.) To umožňuje "
"maximálne využitie šírky pásma aj v prípade oneskorenia prenosu. Mechanizmus "
"časového limitu, opätovného prenosu, okna a potvrdenia sú inšpirované "
"podobnými mechanizmami v [TCP](https://en.wikipedia.org/wiki/"
"Transmission_Control_Protocol)."

msgid ""
"In the other direction, message blocks sent from micro-controller to host "
"are designed to be error-free, but they do not have assured transmission. "
"(Responses should not be corrupt, but they may go missing.) This is done to "
"keep the implementation in the micro-controller simple. There is no "
"automatic retransmission system for responses - the high-level code is "
"expected to be capable of handling an occasional missing response (usually "
"by re-requesting the content or setting up a recurring schedule of response "
"transmission). The sequence number field in message blocks sent to the host "
"is always one greater than the last received sequence number of message "
"blocks received from the host. It is not used to track sequences of response"
" message blocks."
msgstr ""
"V opačnom smere sú bloky správ odosielané z mikrokontroléra hostiteľovi "
"navrhnuté tak, aby boli bezchybné, ale nemajú zabezpečený prenos. (Odpovede "
"by nemali byť poškodené, ale môžu sa stratiť.) Toto sa robí preto, aby bola "
"implementácia v mikrokontroléri jednoduchá. Neexistuje žiadny systém "
"automatického opakovaného prenosu odpovedí – očakáva sa, že kód vysokej "
"úrovne bude schopný zvládnuť občasnú chýbajúcu odpoveď (zvyčajne opätovným "
"vyžiadaním obsahu alebo nastavením opakujúceho sa plánu prenosu odpovedí). "
"Pole poradového čísla v blokoch správ odoslaných hostiteľovi je vždy o jedno "
"väčšie ako posledné prijaté poradové číslo blokov správ prijatých od "
"hostiteľa. Nepoužíva sa na sledovanie sekvencií blokov správ odpovede."

msgid ""
"set_digital_out pin=PA3 value=1\n"
"set_digital_out pin=PA7 value=1\n"
"schedule_digital_out oid=8 clock=4000000 value=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"
msgstr ""
"set_digital_out pin=hodnota PA3=1\n"
"set_digital_out pin=hodnota PA7=1\n"
"schedule_digital_out oid=8 hodín=4000000 hodnota=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"

msgid ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"value=%c\");\n"
msgstr ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"hodnota=%c\");\n"

msgid ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), "
"sched_is_shutdown());\n"
msgstr ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), sched_is_shutdown());"
"\n"

msgid "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"
msgstr "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"

msgid ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"
msgstr ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"

msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
msgstr "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"

msgid "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"
msgstr "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"

msgid ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"
msgstr ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"

msgid ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"
msgstr ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"

msgid ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"
msgstr ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_"
"get_clock>\n"

msgid "<VLQ encoded length><n-byte contents>\n"
msgstr "<VLQ encoded length><n-byte contents>\n"

#: docs/Protocol.md:block 1 (header)
msgid "Protocol"
msgstr "Protokol"
